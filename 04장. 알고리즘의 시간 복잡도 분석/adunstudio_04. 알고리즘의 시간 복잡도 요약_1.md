# 알고리즘의 시간 복잡도 분석

## 반복문이 지배한다.

대게 알고리즘의 수행 시간을 반복문이 수행되는 횟수로 측정한다. 이때 반복문의 수행 횟수는 입력의 크기에 대한 함수로 표현한다.

ex) 주어진 배열에서 가장 많이 드장하는 수를 찾는 코드

이 알고리즘의 수행 시간은 배열의 크기 *N*에 따라 변한다. *N*번 수행되는 반복문이 두 개 겹쳐져 있으므로, 반복문의 가장 안쪽은 항상 *N^2*번 실행된다.

따라서 이 알고리즘의 수행 시간은 *N^2*이다.

```cpp
// 주어진 배열 A에서 가장 많이 등장하는 숫자를 반환하기

int majority1(const vector<int>& A) {
	int N = A.size();
	int majority = -1, majorityCount = 0;
	for(int i = 0; i < N; ++i) {
		// A에 등장하는 A[i]D의 수를 센다.
		int V = A[i], count = 0;
		for(int j = 0; j < N; ++j)
			if(A[j] == V)
				++count;
		
		// 지금까지 본 최대 빈도보다 많이 출현했다면 답을 갱신한다.
		if(count > majorityCount) {
			majorityCount = count;
			majority = V;
		}
	}
	
	return majority;
}
```

입력으로 주어지는 숫자들이 사실 100점 만점으로 주어지는 중간 고사 점수였다고 치자. 

이처럼 숫자의 범위가 작다면 배열을 이용해 각 숫자가 등장하는 횟수를 쉽게 셀 수 있다. 그리고 마지막에 빈도수 배열을 순회하면서 최대치의 위치를 찾으면 된다.

```cpp
// 주어진 배열에서 가장 많이 등장하는 숫자를 반환하기2

// A의 각 원소가 0부터 100 사이의 값일 경우 가장 많이 등장하는 숫자를 반환한다.
int majority2(const vector<int>& A) {
	int N = A.size();
	vecotr<int> count(101, 0);
	for(int i = 0; i < N; ++i)
		++count[A[i]];
	
	// 지금까지 확인한 숫자 중 빈도수가 제일 큰 것을 majority에 저장한다.
	int majority = 0;
	for(int i = 1; i <= 100; ++i) {
		if(count[i] > count[majority])
			majority = i;
	}
	
	return majority;
}
```
위 코드에는 반복문이 두 개 있다. 하나는 *N*번 수행되고, 다른 하나는 100번 수행되므로 전체 반복문의 수행 횟수는 *N* + 100이 된다.

궁극적으로는 이 알고리즘의 수행 시간은 *N*이라고 쓴다.

------------


## 선형 시간 알고리즘

#### 다이어트 현황 파악: 이동 평균 계산하기

이동 평균(moving average)은 주식의 가격, 연간 국내 총생산(GDP), 여자친구의 몸무게 등 시간에 따라 변화하는 값들을 관찰할 때 유용하게 사용할 수 있는 통계적 기준이다.

시간에 따라 관찰된 숫자들이 주어질 떄 *M*-이동 평균은 마지막 *M*개의 관찰 값의 평균으로 정의된다.

아래 그림은 가상의 다이어트 기록이다.

![](http://www.adundocs.xyz/upload/1501781613tat.jpg)

ex) *N*개의 측정치가 주어질 때 매달 *M*달간의 이동 평균을 계산하는 프로그램을 만들어보자.

```cpp
// 이동 평균 구하기
// 실수 배열 A가 주어질 때, 각 위치에서의 M-이동 평균 값을 구한다.
vecotr<doble> movingAverage1(const vector<double>& A, int M) {
	vector<double> ret;
	int N = A.size();
	for(int i = M-1; i < N; ++i) {
		// A[i]까지의 이동 평균 값을 구하자.
		double partialSum = 0;
		for(int j = 0; j < M; ++j)
			partialSum += A[i-j];
		ret.push_back(partialSum / M);
	}
	
	return ret;
}
```

위 코드의 수행 시간은 두 개의 for문에 의해 지배된다. *j*를 사용하는 반복문은 항상 *M*번 실행되고 *i*를 상횽하는 반복문은 *N - M + 1*번 실행되니, 전체 반복문은 *M * (N-M+1) = N\*M-M^2+N*번 반복된다.

N=12, M=3이면 반복 횟수는 30번이 된다.

좀 더 빠른 프로그램을 짤 수 있는지 알아보자. 여기에서 중요한 아이디어는 중복된 계산을 없애는 것이다.

측정치가 M개는 되어야 이동 평균을 계산할 수 있으니, 태어난 이후 M-1일부터 이동 평균을 계산할 수 있다.

이때 M-1일의 이동 평균과 M일의 이동 평균에 포함되는 숫자들을 비교 해보면 이 둘은 0일과 M일의 몸무게를 제외하면 전 부 겹친다는 것을 알 수 있다.

M-1일에 구했떤 몸무게의 합에서 0일째에 층정한 몸무게를 빼고 M일째에 측정한 몸무게를 더하면 된다.

```cpp
// 선형 시간에 이동 평균 구하기

// 길이가 N인 실수 배열 A가 주어질 떄, 각 위치에서의 M-이동 평균 값을 구한다.
vector<double> movingAverage2(const vector<double>& A, int M) {
	vector<double> ret;
	double partialSum = 0;
	
	for(int i = 0; i < M-1; ++i)
		partialSum += A[i];
	
	for(int i = M-1; i < N; ++i) {
		partialSum += A[i];
		ret.push_back(partialSum / M);
		partialSum -= A[i-M+1];
	}
	
	return ret;
}
```

위 코드의 수행 시간은 N에 정비례한다. 입력의 크기에 대비해 걸리는 시간을 그래프로 그려 보면 정확히 직선이 된다.

때문에 이런 알고리즘을 선형 시간(linear time) 알고리즘이라고 부른다.

------------

## 선형 이하 시간 알고리즘

입력의 크기가 커지는 것보다 수행 시간이 느리게 증가하는 알고리즘들을 선형 이가 시간(sunlinear time) 알고리즘이라고 부른다.


### 이진 탐색

이진 탐색(binary search) 알고리즘이 하는 일을 다음과 같이 정의할 수 있다.

binsearch(A[], x) = 오름차순으로 정렬된 배열 A[]와 찾고 싶은 값 x가 주어질 때 A[i-1] < x <= A[i]인 i를 반환한다. 이때 A[-1] = ~∞, A[M]=∞로 가정한다.

함수가 배열 A[]에서 x를 삽입할 수 있는 위치 중 가장 앞에 있는 것을 반환한다고 생각하면 좀 더 쉽다.

------------

## 지수 시간 알고리즘

### 다항 시간 알고리즘

변수 N과 N^2, 그 외 N의 거듭제곱들의 선형 결합으로 이루어진 식들을 다항식이라고 부른다. 반복문의 수행 횟수를 입력 크기의 다항식으로 표현할 수 잇는 알고리즘들을 다항 시간 알고리즘이라고 부른다.

#### 알러지가 심한 친구들

![](http://www.adundocs.xyz/upload/15018488561.jpg)

위와 같이 알러지가 심한 경우에 각 친구가 먹을 수 있는 음식이 최소한 하나씩은 있으려면 최소 몇 가지의 음식을 해야할까?

다 같이 먹을 수 있는 음식이 없기 떄문에 결국 두 가지 음식을 해야 한다. (피자 + 탕수육 or 잡채 + 닭강정)

#### 모든 답 후보를 평가하기

이 문제에서는 여러 개의 답이 있을 수 있다. 

그러나 더 적은 종류의 음식만을 준비하고 싶다. 이렇게 여러 개의 답이 있고 그중 가장 좋은 답을 찾는 문제들을 풀 때 가장 간단한 방법은 모든 답을 일일이 고려해 보는 것이다.

만들 수 잇는 음식의 모든 목록을 만드는 과정은 여러 개의 결정으로 나누면 자연스럽다.

![](http://www.adundocs.xyz/upload/15018494562.jpg)

그림처럼 텅 빈 목록부터 시작해서 각 음식을 만들지 말지니를 선택해 나간다. 그림에서는 생략 했지만, 이렇게 그림의 맨 끝까지 내려가 보면 마지막 층에는 존재 가능한 모든 목록을 만나게된다.

이제 모든 사람들이 식사할 수 잇는 목록들만 골라낸 뒤 가장 음식의 수가 적은 목록을 찾으면 된다.

위와 같은 알고리즘을 구현하는 가장 쉬운 방법은 재귀 호출을 이용하는 것이다. 이때 재귀 함수는 그림에서의 한 상태를 입력받아 이 상태 밑에 달린 모든 후보들을 검사하고 이 중 가장 좋은 답을 반환하는 역활을 한다.

selectMenu()는 지금까지 만들기로 정한 메뉴와 몇 번 음식을 결정할 차례인지를 입력받아 가능한 모든 메뉴를 하나씩 시도해 본다.

```cpp
const int INF = 987654321;

// 이 메뉴로 모두가 식사할 수 있는지 여부를 반환한다.
bool canEverybodyEat(const vector<int>& menu);

// 요리할 수 있는 음식의 종류 수
int M;

// food 번 째 음식을 만들지 여부를 결정한다.
int selectMenu(vector<int>& menu, int food) {
	// 기저 사례: 모든 음식에 대해 만들지 여부를 결정했을 때
	if (food == M) {
		if (canEverybodyEat(menu))
			return menu.size();
		// 아무것도 못 먹는 사람이 있으면 아주 큰 값을 반환한다.
		return INF;
	}

	// 이 음식을 만들지 않는 경우의 답을 계산한다.
	int ret = selectMenu(menu, food + 1);

	// 이 음식을 만드는 경우의 답을 계산해서 더 작은 것을 취한다.
	menu.push_back(food);
	ret = min(ret, selectMenu(menu, food + 1));
	menu.pop_back();

	return ret;
}
```

### 지수 시간 알고리즘

위 알고리즘즘에서 M가지의 음식마다 만든다, 만들지 않는다의 두 선택지가 잇으니 만들 수 있는 답은 모두 2^M가지가 된다.

답을 하나 만들 떄마다 canEverbodyEat()을 수행하니 이 알고리즘의 수행 시간은 2^M * canEverybodyEat()의 수행시간이다.

caneEverybodyEat()을 수행할 때 반복문이 N * M번 수행된다고 가정하면 전체 수행시간은 N * M * 2^M이 된다.

2^M과 같은 지수 함수는 알고리즘 전체 수행 시간에 엄청난 영향을 미친다.

이와 같이 N이 하나 증가할 때마다 걸리는 시간이 배로 증가하는 알고리즘들을 지수 시간(exponential time)에 동작한다고 말한다.

### 소인수 분해의 수행 시간

입력으로 주어지는 숫자의 개수가 아니라 그 크기에 다라 수행 시간이 달라지는 알고리즘들 또한 지수 수행 시간을 가질 수 있다.

```cpp
// 자연수 n의 소인수 분해 결과를 담은 정수 배열을 반환한다.
vector<int> factor(int n) {
	if (n == 1) return vector<int>(1, 1); // n=1인 경우는 예외로 한다.

	vector<int> ret;

	for(int div = 2; n > 1; ++div)
		while (n % div == 0) {
			n /= div;
			ret.push_back(div);
		}

	return ret;
}
```

위 알고리즘은 N이 1이 될 때까지 가능한 한 모든 숫자로 N을 나눠본다. 따라서 N의 크기에 따라 반복문의 수행 횟수가 달라진다.

최악의 경우는 주어진 수 N이 소수인 경우다. 이때 반복문의 실행 횟수는 N-1이 된다.

실행 횟수가 대략 N에 비례하기 때문에 이 함수는 최악의 경우에 선형 시간에 걸린다고 생각하기 쉽지만, N이 아무리 커져도 실제 입력은 1개일 뿐인데 수행 시간이 달라진다는 것은 영 직관에 맞지 않다.

소인수 분해 문제는 입력으로 주어지는 숫자가 알고리즘의 동작에 직접적인 영향을 미치므로, 숫자가 특정 범위 안에 있다고 가정할 수 없다. 입력의 값이 커지면 커질수록 숫자를 저장하는데 필요한 메모리의 공간도 증가한다. 이때 입력이 차지하는 비트의 수에 따라 수행 시간이 증가한다고 생각하면 아까의 불일치를 직관적으로 설명할 수 있다.

비트의 수가 하나 증가할 때마다 표현할 수 있는 수의 범위와 알고리즘의 최대 수행 시간은 두 배로 증가한다. 이렇게 입력의 크기를 입력이 차지하는 비트 수로 정의하면 입력의 크기에 대해 지수 시간이 걸린다고 말할 수 있다.

------------